<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GuestScan — Interactive DNA-Binding Register Scanner</title>

<!-- Mol* Viewer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/molstar@4.5.0/build/viewer/molstar.css">
<script src="https://cdn.jsdelivr.net/npm/molstar@4.5.0/build/viewer/molstar.js"></script>

<!-- PyScript / Pyodide -->
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>

<style>
/* ── Reset & Base ─────────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: Verdana, Helvetica, Arial, sans-serif;
  background: #fff;
  color: dimgrey;
  font-size: 0.8em;
  line-height: 1.5;
  min-height: 100vh;
}

h1 {
  font-family: times, 'Times New Roman', georgia, serif;
  color: #444; font-size: 31px; line-height: 34px;
  letter-spacing: -1px; font-weight: bold;
  margin: 0; padding: 0 0 6px 0;
}
h2 {
  font-family: 'Gill Sans', Verdana, sans-serif;
  font-size: 11px; line-height: 14px;
  text-transform: uppercase; letter-spacing: 2px; font-weight: bold;
  color: #444; margin-bottom: 0.5rem;
}
h3 {
  font-family: 'Gill Sans', Verdana, sans-serif;
  color: gray; font-size: 18px; font-weight: lighter;
  line-height: 22px; letter-spacing: -0.5px;
  margin: 0 0 0.4rem 0;
}

/* ── Page wrapper ────────────────────────────────────── */
.page-wrap { max-width: 745px; margin: 0 auto; padding: 0 12px; }

.app-header {
  padding: 14px 0 8px 0;
  border-bottom: 2px solid papayawhip;
  display: flex; align-items: baseline; gap: 12px;
}
.app-header .subtitle {
  font-family: 'Gill Sans', Verdana, sans-serif;
  color: silver; font-size: 11px; text-transform: uppercase;
  letter-spacing: 2px; font-weight: bold;
}

.app-intro {
  padding: 8px 0 10px 0;
  color: dimgrey; font-size: 0.95em;
  border-bottom: 1px solid #eee;
  margin-bottom: 10px;
}

/* ── Inset panels (stages) ───────────────────────────── */
.stage {
  margin: 10px 0;
  background: #f7f7f7;
  border: 1px solid #dcdcdc;
  border-radius: 10px;
  overflow: hidden;
}
.stage-header {
  padding: 8px 12px;
  background: yellowgreen;
  border-bottom: 1px solid #9ab834;
  font-family: 'Gill Sans', Verdana, sans-serif;
  font-size: 11px; text-transform: uppercase;
  letter-spacing: 2px; font-weight: bold;
  color: #000;
}
.stage-body { padding: 12px; }

/* ── Form elements ────────────────────────────────────── */
label { font-size: 0.9em; color: gray; display: block; margin-bottom: 2px; }
select, input[type="text"], input[type="number"], input[type="file"] {
  background: #fff; color: #444;
  border: 1px solid #ccc; border-radius: 4px;
  padding: 4px 6px; font-size: 0.95em;
  width: 100%;
}
select:focus, input:focus { outline: none; border-color: #999; box-shadow: 0 0 0 2px rgba(153,153,153,0.15); }
input[type="number"] { width: 5rem; }
input[type="file"] { padding: 3px; }

.btn {
  background: #888; color: #fff;
  border: none; border-radius: 6px;
  padding: 6px 14px; font-size: 0.95em;
  cursor: pointer; font-weight: bold;
  font-family: 'Gill Sans', Verdana, sans-serif;
  transition: background 0.15s;
}
.btn:hover { background: #666; }
.btn:disabled { opacity: 0.35; cursor: not-allowed; }
.btn-primary { background: yellowgreen; color: #000; }
.btn-primary:hover { background: yellowgreen; color: #000; box-shadow: 0 0 0 3px #333; }

.checkbox-row { display: flex; align-items: center; gap: 0.4rem; margin: 0.3rem 0; }
.checkbox-row input[type="checkbox"] { width: auto; }

/* ── Layout ───────────────────────────────────────────── */
.row { display: flex; gap: 12px; flex-wrap: wrap; }
.col { flex: 1; min-width: 260px; }

/* ── Mol* viewer containers ───────────────────────────── */
.viewer-wrap {
  background: #000;
  border: 1px solid #ccc;
  border-radius: 8px;
  overflow: hidden;
  position: relative;
}
.viewer-wrap .viewer-label {
  position: absolute; top: 4px; left: 8px;
  font-size: 0.75em; color: #ccc;
  z-index: 10; pointer-events: none;
  background: rgba(0,0,0,0.55); padding: 1px 6px; border-radius: 3px;
}
.molstar-container { width: 100%; height: 400px; }

/* ── PDB input section ────────────────────────────────── */
.pdb-input-row {
  display: flex; gap: 0.5rem; align-items: flex-end; flex-wrap: wrap;
  margin-bottom: 0.8rem;
}
.pdb-input-row .or-text { color: gray; font-size: 0.9em; padding-bottom: 4px; }

/* ── Progress bar ─────────────────────────────────────── */
.progress-wrap { margin: 6px 0; }
.progress-bar-bg {
  background: #e8e8e8; border-radius: 6px;
  height: 24px; overflow: hidden; position: relative;
}
.progress-bar-fill {
  background: linear-gradient(90deg, darkseagreen, yellowgreen);
  height: 100%; border-radius: 6px;
  transition: width 0.2s ease;
  background-size: 30px 30px;
  background-image: repeating-linear-gradient(
    45deg, transparent, transparent 10px,
    rgba(255,255,255,0.18) 10px, rgba(255,255,255,0.18) 20px);
  animation: stripe 0.8s linear infinite;
}
.progress-bar-fill.done { animation: none; background-image: none; }
@keyframes stripe {
  0% { background-position: 0 0; }
  100% { background-position: 30px 0; }
}
.progress-text {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  display: flex; align-items: center; justify-content: center;
  font-size: 0.85em; font-weight: bold; color: #555;
  pointer-events: none;
}

/* ── Status messages ──────────────────────────────────── */
.status { font-size: 0.9em; margin: 4px 0; min-height: 1.2em; }
.status.ok { color: seagreen; }
.status.error { color: indianred; }
.status.info { color: steelblue; }

/* ── Results summary ──────────────────────────────────── */
.summary-box {
  background: #fff;
  border: 1px solid #dcdcdc;
  border-radius: 8px;
  padding: 10px;
  font-size: 0.95em;
}
.summary-box .metric { margin: 2px 0; }
.summary-box .metric strong { color: #444; }

/* ── SVG diagram container ────────────────────────────── */
#svg-container {
  overflow-x: auto;
  background: #111;
  border-radius: 8px;
  padding: 8px;
  margin-top: 8px;
}
#svg-container svg { display: block; max-width: 100%; height: auto; }

/* ── Loading overlay ──────────────────────────────────── */
#loading-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.92);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 1000;
}
#loading-overlay .spinner {
  width: 40px; height: 40px;
  border: 3px solid #ddd;
  border-top-color: darkseagreen;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
#loading-overlay .msg { margin-top: 1rem; color: gray; font-size: 0.95em; }

/* ── Selection row (horizontal form layout) ──────────── */
.selection-row {
  display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-start;
  margin-bottom: 4px;
}
.sel-group { min-width: 120px; }
.sel-group select { width: 100%; }

/* ── dsDNA drag selector ─────────────────────────────── */
.dna-selector { overflow-x: auto; margin: 8px 0; padding: 8px;
  background: #fff; border: 1px solid #dcdcdc; border-radius: 6px; }
.dna-selector-inner { display: inline-flex; flex-direction: column;
  user-select: none; cursor: crosshair; }
.dna-row { display: flex; align-items: center; white-space: nowrap; }
.dna-label { font-size: 0.7em; color: gray; width: 55px; flex-shrink: 0;
  text-align: right; padding-right: 4px; font-family: 'Courier New', monospace; }
.dna-end { font-size: 0.65em; color: gray; padding: 0 3px; flex-shrink: 0; }
.bp-cell { display: inline-block; width: 18px; text-align: center;
  font-family: 'Courier New', monospace; font-size: 0.8em; font-weight: bold;
  color: #555; padding: 1px 0; flex-shrink: 0; }
.bp-pipe { display: inline-block; width: 18px; text-align: center;
  font-size: 0.7em; color: #ccc; flex-shrink: 0; }
.bp-cell.selected { background: yellowgreen; color: #000; border-radius: 2px; }
.bp-cell:hover { background: #e8e8e8; border-radius: 2px; }
.bp-cell.selected:hover { background: #9acd32; }
.bp-resid { display: inline-block; width: 18px; text-align: center;
  font-size: 0.55em; color: silver; flex-shrink: 0; overflow: visible; }
.dna-sel-warning { color: indianred; font-weight: bold; }
.dna-sel-label { font-size: 0.8em; color: gray; margin-bottom: 4px; }

/* ── Scaffold toggle switch ──────────────────────────── */
.scaffold-toggle { display: inline-block; }
.toggle-checkbox { display: none; }
.toggle-label {
  display: flex; align-items: center; gap: 10px;
  cursor: pointer; user-select: none;
  font-size: 1em; font-weight: bold;
  font-family: 'Gill Sans', Verdana, sans-serif;
}
.toggle-opt { transition: color 0.2s; }
.toggle-opt small { font-weight: normal; color: gray; }
.toggle-left { color: #444; }
.toggle-right { color: silver; }
.toggle-checkbox:checked ~ .toggle-label .toggle-left { color: silver; }
.toggle-checkbox:checked ~ .toggle-label .toggle-right { color: #444; }

.toggle-switch {
  position: relative;
  width: 52px; height: 28px;
  background: darkseagreen;
  border-radius: 14px;
  transition: background 0.2s;
  flex-shrink: 0;
}
.toggle-switch::after {
  content: '';
  position: absolute;
  top: 3px; left: 3px;
  width: 22px; height: 22px;
  background: #fff;
  border-radius: 50%;
  transition: transform 0.2s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.toggle-checkbox:checked ~ .toggle-label .toggle-switch::after { transform: translateX(24px); }

.hidden { display: none !important; }
</style>
</head>

<body>

<!-- Loading overlay (shown while Pyodide loads) -->
<div id="loading-overlay">
  <div class="spinner"></div>
  <div class="msg">Loading Pyodide &amp; NumPy...</div>
</div>

<div class="page-wrap">

<!-- Header -->
<header class="app-header">
  <h1>GuestScan</h1>
  <span class="subtitle">Interactive Register Scanner</span>
</header>
<p class="app-intro">
  The purpose of this utility is to explore the sterics and symmetry of installing different
  DNA-binding domains within the porous scaffold crystals reported by the Snow laboratory.
</p>

<!-- ═══ Stage 1: Load Guest Protein ═══════════════════════════════ -->
<section class="stage" id="stage1">
  <div class="stage-header">Stage 1: Load &amp; Configure Guest Protein</div>
  <div class="stage-body">

    <p style="font-size:0.85rem; color:gray; margin-bottom:0.8rem">
      <strong>Step 1.</strong> Upload or fetch a model of your DNA-binding domain of interest.
    </p>

    <!-- PDB input -->
    <div style="margin-bottom:0.8rem">
      <label>Guest PDB</label>
      <div class="pdb-input-row">
        <input type="file" id="pdb-upload" accept=".pdb,.ent">
        <span class="or-text">or</span>
        <input type="text" id="pdb-code" placeholder="PDB code" style="width:6rem">
        <button class="btn btn-primary" id="btn-fetch" onclick="fetchPDB()">Fetch</button>
      </div>
    </div>

    <!-- Viewer 1: Full PDB (full width) -->
    <div class="viewer-wrap" style="margin-bottom:1rem">
      <span class="viewer-label">Full PDB</span>
      <div id="viewer1" class="molstar-container"></div>
    </div>

    <!-- Step 2: Selection form -->
    <p style="font-size:0.85rem; color:gray; margin-bottom:0.5rem">
      <strong>Step 2. Truncation.</strong> Use the fields below to truncate your input model so that it has
      just one instance of your DNA binding domain and a minimal dsDNA segment it is bound to.
      For the downstream scan, your minimal dsDNA needs to be simple contiguous canonical basepairs (no missing bases).
      You can identify the chains and residue IDs by hovering over the model from Step 1.
      Once you think you have your minimal model, try pressing <em>Preview Selection</em> to check.
      Once your minimal model looks correct, proceed to Stage 2.
    </p>
    <h3>Chain &amp; Residue Selection</h3>
    <div class="selection-row">
      <div class="sel-group">
        <label>Protein chain(s):</label>
        <select id="sel-prot-chains" multiple size="2" style="width:100%"></select>
      </div>
      <div class="sel-group">
        <label>DNA chain 1:</label>
        <select id="sel-dna1-chain"></select>
        <div style="display:flex; gap:0.4rem; margin-top:0.3rem">
          <div><label>lo:</label><input type="number" id="sel-dna1-lo"></div>
          <div><label>hi:</label><input type="number" id="sel-dna1-hi"></div>
        </div>
      </div>
      <div class="sel-group">
        <label>DNA chain 2:</label>
        <select id="sel-dna2-chain"></select>
        <div style="display:flex; gap:0.4rem; margin-top:0.3rem">
          <div><label>lo:</label><input type="number" id="sel-dna2-lo"></div>
          <div><label>hi:</label><input type="number" id="sel-dna2-hi"></div>
        </div>
      </div>
      <div class="sel-group" style="align-self:end">
        <div class="checkbox-row">
          <input type="checkbox" id="sel-hetatm">
          <label for="sel-hetatm" style="display:inline; margin:0">Include HETATM</label>
        </div>
      </div>
    </div>

    <div id="dna-selector-wrap" class="hidden" style="margin-top:0.5rem">
      <div class="dna-sel-label">dsDNA Base Pairing — <em>drag to select region</em>
        (<strong><span id="dna-sel-count">0</span> bp</strong> selected)
        <span id="dna-sel-warning" class="dna-sel-warning"></span></div>
      <div id="dna-selector" class="dna-selector"></div>
    </div>

    <div style="margin-top:0.6rem; display:flex; gap:0.5rem; align-items:center">
      <button class="btn btn-primary" id="btn-preview" onclick="previewSelection()" disabled>Preview Selection</button>
      <span class="status" id="status-selection"></span>
    </div>

    <!-- Viewer 2: Truncated Guest -->
    <div class="viewer-wrap" style="margin-top:0.8rem">
      <span class="viewer-label">Truncated Guest</span>
      <div id="viewer2" class="molstar-container" style="height:320px"></div>
    </div>

  </div>
</section>

<!-- ═══ Stage 2: Scan ════════════════════════════════════════════ -->
<section class="stage" id="stage2">
  <div class="stage-header">Stage 2: Scan</div>
  <div class="stage-body">
    <div style="display:flex; align-items:center; justify-content:center; gap:2rem; flex-wrap:wrap; margin-bottom:0.8rem">
      <!-- Scaffold toggle -->
      <div class="scaffold-toggle">
        <input type="checkbox" id="scaffold-toggle" class="toggle-checkbox">
        <label for="scaffold-toggle" class="toggle-label">
          <span class="toggle-opt toggle-left">CC1<sup>+10</sup> <small>(31 bp)</small></span>
          <span class="toggle-switch"></span>
          <span class="toggle-opt toggle-right">CC1<sup>+21</sup> <small>(42 bp)</small></span>
        </label>
      </div>
      <button class="btn btn-primary" id="btn-scan" onclick="startScan()" disabled style="font-size:1rem; padding:0.6rem 2rem">
        Scan Possible Binding Registers
      </button>
    </div>
    <div class="progress-wrap">
      <div class="progress-bar-bg">
        <div class="progress-bar-fill" id="progress-fill" style="width:0%"></div>
        <div class="progress-text" id="progress-text">Ready</div>
      </div>
    </div>
    <div class="status info" id="status-pipeline"></div>
  </div>
</section>

<!-- ═══ Stage 3: Results ══════════════════════════════════════════ -->
<section class="stage hidden" id="stage3">
  <div class="stage-header">Stage 3: Results</div>
  <div class="stage-body">
    <div class="row">
      <!-- Viewer 3 -->
      <div class="col">
        <div class="viewer-wrap">
          <span class="viewer-label" id="viewer3-label">Rank 1</span>
          <div id="viewer3" class="molstar-container"></div>
        </div>
      </div>
      <!-- Summary + download -->
      <div class="col" style="max-width:154px; min-width:130px; flex:0 0 auto">
        <div class="summary-box" id="results-summary" style="font-size:0.85em"></div>
        <button class="btn btn-primary" id="btn-download-pdb" onclick="downloadCurrentPdb()" style="margin-top:6px; width:100%; font-size:0.75em; padding:5px 6px">
          Download Model (.pdb)
        </button>
        <button class="btn btn-primary" id="btn-download-seqs" onclick="downloadSequences()" style="margin-top:4px; width:100%; font-size:0.75em; padding:5px 6px">
          Download Sequences (.txt)
        </button>
        <p style="margin-top:6px; font-size:0.6em; color:#333; line-height:1.4">
          <strong>Key:</strong> Scaffold protein RepE54 (<span style="color:#7ec8e3">light blue</span>), Target guest site (<span style="color:#cc0088">magenta</span>), Closest guest symmetry mate (<span style="color:#ffaacc">pink</span>)
        </p>
        <p style="margin-top:4px; font-size:0.6em; color:silver; line-height:1.3">
          Left-click to rotate, scroll to zoom, control-left-click or right-click to pan, shift-scroll to adjust clipping.
        </p>
      </div>
    </div>

    <p style="margin-top:10px; margin-bottom:6px">
      You can click on the different sliding window options below to see
      the different guest DBD placements.
    </p>
    <h3>Register Diagram <span style="color:silver;font-size:0.75em">(click a bar to view in 3D)</span></h3>
    <div id="svg-container"></div>
    <p style="margin-top:8px; line-height:1.5">
      This diagram shows possible binding registers that might be sterically feasible, colored
      by how close they get to other biomolecules within the lattice (excluding their dsDNA stack).
      The register with the green boundary is the currently selected model. The candidate registers with magenta boundaries overlap with the scaffold protein (RepE54)
      binding window which will presumably prevent freely changing the sequence in pursuit of
      guest installation.
    </p>
  </div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<!--  JavaScript Layer                                             -->
<!-- ═══════════════════════════════════════════════════════════════ -->
<script>
// ── Global state ────────────────────────────────────────────────
let guestPdbString = null;      // Full uploaded PDB text
let truncatedPdbStr = null;     // After step A
let scaffoldCode = '9YZJ';
let scaffoldData = {};          // Pre-fetched scaffold/mate data
let registerPdbs = {};          // obj_name -> pdb string (from pipeline)
let registerSymPdbs = {};       // obj_name -> symmetry copy pdb string
let rankedResults = [];         // Ranked register list
let activeRegister = null;      // Currently displayed register

// Mol* plugin instances
let plugin1 = null, plugin2 = null, plugin3 = null;

// ── Mol* Viewer Init ────────────────────────────────────────────
async function initViewers() {
    const opts = {
        layoutIsExpanded: false,
        layoutShowControls: false,
        layoutShowRemoteState: false,
        layoutShowSequence: false,
        layoutShowLog: false,
        viewportShowExpand: false,
        viewportShowSelectionMode: false,
        viewportShowAnimation: false,
    };
    plugin1 = await molstar.Viewer.create('viewer1', opts);
    plugin2 = await molstar.Viewer.create('viewer2', opts);
    plugin3 = await molstar.Viewer.create('viewer3', opts);
}

async function loadPdbInViewer(viewer, pdbString, label) {
    if (!viewer || !pdbString) return;
    await viewer.plugin.clear();
    await viewer.loadStructureFromData(pdbString, 'pdb', { dataLabel: label || 'structure' });
    hideWaterAndIons(viewer);
    applyStylized(viewer);
}

function hideWaterAndIons(viewer) {
    const hm = viewer.plugin.managers.structure.hierarchy;
    const hideKeys = new Set([
        'structure-component-static-water',
        'structure-component-static-ligand',
        'structure-component-static-ion',
        'structure-component-static-lipid',
        'structure-component-static-branched',
        'structure-component-static-non-standard',
        'structure-component-static-coarse',
    ]);
    const toHide = [];
    for (const struct of hm.current.structures) {
        for (const comp of struct.components) {
            if (hideKeys.has(comp.key)) toHide.push(comp);
        }
    }
    if (toHide.length > 0) hm.toggleVisibility(toHide, 'hide');
}

function applyStylized(viewer) {
    const plugin = viewer.plugin;
    const c3d = plugin.canvas3d;
    if (!c3d) return;
    plugin.managers.structure.component.setOptions({
        ...plugin.managers.structure.component.state.options,
        ignoreLight: true,
    });
    c3d.setProps({ camera: { mode: 'orthographic' } });
    const pp = c3d.props.postprocessing;
    c3d.setProps({
        postprocessing: {
            outline: {
                name: 'on',
                params: pp.outline.name === 'on' ? pp.outline.params : {
                    scale: 1, color: 0x000000, threshold: 0.33, includeTransparent: true,
                }
            },
            occlusion: {
                name: 'on',
                params: pp.occlusion.name === 'on' ? pp.occlusion.params : {
                    multiScale: { name: 'off', params: {} },
                    radius: 5, bias: 0.8, blurKernelSize: 15, blurDepthBias: 0.5,
                    samples: 32, resolutionScale: 1, color: 0x000000,
                }
            },
            shadow: { name: 'off', params: {} },
        }
    });
}

// ── Pre-fetch scaffold data ─────────────────────────────────────
async function fetchScaffoldData(code) {
    const base = '.';
    const [scaffJson, scaffPdb, matesJson, botPdb, topPdb] = await Promise.all([
        fetch(`${base}/scaffold_${code}.json`).then(r => r.json()),
        fetch(`${base}/scaffold_${code}.pdb`).then(r => r.text()),
        fetch(`${base}/mates_${code}.json`).then(r => r.json()),
        fetch(`${base}/mate_${code}_bot.pdb`).then(r => r.text()),
        fetch(`${base}/mate_${code}_top.pdb`).then(r => r.text()),
    ]);
    scaffoldData[code] = {
        json: scaffJson,
        pdb: scaffPdb,
        matesJson: matesJson,
        botPdb: botPdb,
        topPdb: topPdb,
    };
}

// ── PDB Fetching ────────────────────────────────────────────────
async function fetchPDB() {
    const code = document.getElementById('pdb-code').value.trim();
    if (!code || code.length < 4) {
        setStatus('status-selection', 'Enter a 4-letter PDB code', 'error');
        return;
    }
    setStatus('status-selection', `Fetching ${code.toUpperCase()} from RCSB...`, 'info');
    try {
        const resp = await fetch(`https://files.rcsb.org/download/${code.toUpperCase()}.pdb`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        guestPdbString = await resp.text();
        onPdbLoaded();
    } catch(e) {
        setStatus('status-selection', `Failed to fetch: ${e.message}`, 'error');
    }
}

// ── File upload handler ─────────────────────────────────────────
document.getElementById('pdb-upload').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(ev) {
        guestPdbString = ev.target.result;
        onPdbLoaded();
    };
    reader.readAsText(file);
});

// ── Scaffold toggle ─────────────────────────────────────────────
document.getElementById('scaffold-toggle').addEventListener('change', function(e) {
    scaffoldCode = e.target.checked ? '9YZK' : '9YZJ';
});

// ── Chain/Residue Detection ─────────────────────────────────────
function parsePdbChains(pdbText) {
    const chains = {};
    const dnaResnames = new Set(['DA', 'DT', 'DC', 'DG', ' DA', ' DT', ' DC', ' DG']);
    const lines = pdbText.split('\n');
    for (const line of lines) {
        if (!line.startsWith('ATOM')) continue;  // skip HETATM (water/ions break DNA detection)
        if (line.length < 54) continue;
        const chain = line[21];
        const resi = parseInt(line.substring(22, 26).trim());
        const resn = line.substring(17, 20).trim();
        if (!chains[chain]) {
            chains[chain] = { resids: new Set(), resnames: new Set(), isDna: true };
        }
        chains[chain].resids.add(resi);
        chains[chain].resnames.add(resn);
    }
    const result = {};
    for (const [ch, info] of Object.entries(chains)) {
        const resids = Array.from(info.resids).sort((a,b) => a-b);
        const isDna = [...info.resnames].every(rn => dnaResnames.has(rn));
        result[ch] = {
            type: isDna ? 'DNA' : 'protein',
            lo: resids[0],
            hi: resids[resids.length - 1],
            count: resids.length,
        };
    }
    return result;
}

function populateSelectionForm(chainInfo) {
    const protSel = document.getElementById('sel-prot-chains');
    const dna1Sel = document.getElementById('sel-dna1-chain');
    const dna2Sel = document.getElementById('sel-dna2-chain');

    protSel.innerHTML = '';
    dna1Sel.innerHTML = '';
    dna2Sel.innerHTML = '';

    const protChains = [];
    const dnaChains = [];
    for (const [ch, info] of Object.entries(chainInfo)) {
        if (info.type === 'protein') protChains.push(ch);
        else dnaChains.push(ch);
    }

    for (const ch of protChains) {
        const opt = document.createElement('option');
        opt.value = ch; opt.text = `${ch} (${chainInfo[ch].count} res)`;
        opt.selected = true;
        protSel.appendChild(opt);
    }

    for (let i = 0; i < dnaChains.length; i++) {
        const ch = dnaChains[i];
        const info = chainInfo[ch];

        const opt1 = document.createElement('option');
        opt1.value = ch; opt1.text = `${ch} (${info.lo}-${info.hi})`;
        if (i === 0) opt1.selected = true;
        dna1Sel.appendChild(opt1);

        const opt2 = document.createElement('option');
        opt2.value = ch; opt2.text = `${ch} (${info.lo}-${info.hi})`;
        if (i === 1) opt2.selected = true;
        dna2Sel.appendChild(opt2);
    }

    // Auto-populate residue ranges
    if (dnaChains.length >= 1) {
        const ch1 = dnaChains[0];
        document.getElementById('sel-dna1-lo').value = chainInfo[ch1].lo;
        document.getElementById('sel-dna1-hi').value = chainInfo[ch1].hi;
    }
    if (dnaChains.length >= 2) {
        const ch2 = dnaChains[1];
        document.getElementById('sel-dna2-lo').value = chainInfo[ch2].lo;
        document.getElementById('sel-dna2-hi').value = chainInfo[ch2].hi;
    }

    // Update ranges when DNA chain selection changes
    dna1Sel.onchange = function() {
        const info = chainInfo[this.value];
        if (info) {
            document.getElementById('sel-dna1-lo').value = info.lo;
            document.getElementById('sel-dna1-hi').value = info.hi;
        }
        initDnaSelector();
    };
    dna2Sel.onchange = function() {
        const info = chainInfo[this.value];
        if (info) {
            document.getElementById('sel-dna2-lo').value = info.lo;
            document.getElementById('sel-dna2-hi').value = info.hi;
        }
        initDnaSelector();
    };

    // Initialize dsDNA drag selector
    initDnaSelector();
}

// ── Normalize modified nucleotide bases ──────────────────────────
// Promote HETATM → ATOM and rename to standard DNA residue names
// so the pipeline correctly processes modified bases (e.g. OMC → DC).
function normalizeModifiedBases(pdbText) {
    const modToStd = {
        OMC: 'DC', '5MC': 'DC', CBR: 'DC', '5CM': 'DC',
        OMG: 'DG', '2MG': 'DG', '7MG': 'DG', M2G: 'DG',
        OMA: 'DA', '1MA': 'DA', '6MA': 'DA', MA6: 'DA',
        OMU: 'DT', '5MU': 'DT', '5BU': 'DT', BRU: 'DT', PSU: 'DT',
    };
    return pdbText.split('\n').map(line => {
        if (line.length < 27) return line;
        const isHetatm = line.startsWith('HETATM');
        if (!line.startsWith('ATOM') && !isHetatm) return line;
        const resn = line.substring(17, 20).trim();
        if (!modToStd[resn]) return line;
        const stdResn = modToStd[resn].padStart(3);
        const prefix = isHetatm ? 'ATOM  ' : line.substring(0, 6);
        return prefix + line.substring(6, 17) + stdResn + line.substring(20);
    }).join('\n');
}

// ── After PDB is loaded ─────────────────────────────────────────
function onPdbLoaded() {
    guestPdbString = normalizeModifiedBases(guestPdbString);
    setStatus('status-selection', 'PDB loaded, parsing chains...', 'info');
    const chainInfo = parsePdbChains(guestPdbString);
    populateSelectionForm(chainInfo);
    loadPdbInViewer(plugin1, guestPdbString, 'Full PDB');
    document.getElementById('btn-preview').disabled = false;
    document.getElementById('btn-scan').disabled = false;
    setStatus('status-selection', `Loaded: ${Object.keys(chainInfo).length} chains detected`, 'ok');
}

// ── Preview Selection ───────────────────────────────────────────
async function previewSelection() {
    if (!guestPdbString || !window.pyValidate) return;
    setStatus('status-selection', 'Validating selection...', 'info');

    const params = getSelectionParams();
    try {
        const result = window.pyValidate(
            guestPdbString, JSON.stringify(params.protChains),
            params.dna1Chain, params.dna1Lo, params.dna1Hi,
            params.dna2Chain, params.dna2Lo, params.dna2Hi
        );
        const res = JSON.parse(result);
        if (res.ok) {
            setStatus('status-selection', res.message, 'ok');
            truncatedPdbStr = window.pyStepA(
                guestPdbString, JSON.stringify(params.protChains),
                params.dna1Chain, params.dna1Lo, params.dna1Hi,
                params.dna2Chain, params.dna2Lo, params.dna2Hi,
                params.hetatm
            );
            loadPdbInViewer(plugin2, truncatedPdbStr, 'Truncated Guest');
        } else {
            setStatus('status-selection', res.message, 'error');
        }
    } catch(e) {
        setStatus('status-selection', `Error: ${e.message}`, 'error');
    }
}

function getSelectionParams() {
    const protSel = document.getElementById('sel-prot-chains');
    const protChains = Array.from(protSel.selectedOptions).map(o => o.value);
    return {
        protChains: protChains,
        dna1Chain: document.getElementById('sel-dna1-chain').value,
        dna1Lo: parseInt(document.getElementById('sel-dna1-lo').value),
        dna1Hi: parseInt(document.getElementById('sel-dna1-hi').value),
        dna2Chain: document.getElementById('sel-dna2-chain').value,
        dna2Lo: parseInt(document.getElementById('sel-dna2-lo').value),
        dna2Hi: parseInt(document.getElementById('sel-dna2-hi').value),
        hetatm: document.getElementById('sel-hetatm').checked,
    };
}

// ── dsDNA Base Pairing Detection & Drag Selector ────────────────
let bpPairs = [];
let selStart = 0, selEnd = 0;
let bpDragging = false, dragAnchor = null;
let dnaChainResids = {};  // chain -> sorted array of all resids on that chain

function detectBasePairing(pdbText, chain1, chain2) {
    // Parse C1' atoms and base identity for each residue on both chains
    const WC = { A: 'T', T: 'A', G: 'C', C: 'G' };
    const resNameToBase = {
        DA: 'A', DT: 'T', DC: 'C', DG: 'G',           // standard DNA
        A: 'A', T: 'T', C: 'C', G: 'G', U: 'T',       // standard RNA
        OMC: 'C', '5MC': 'C', CBR: 'C', '5CM': 'C',    // modified C
        OMG: 'G', '2MG': 'G', '7MG': 'G', M2G: 'G',    // modified G
        OMA: 'A', '1MA': 'A', '6MA': 'A', MA6: 'A',    // modified A
        OMU: 'T', '5MU': 'T', '5BU': 'T', BRU: 'T', PSU: 'T',  // modified T/U
    };

    function parseChainC1(text, chainId) {
        const residues = {};  // resid -> {x, y, z, base}
        for (const line of text.split('\n')) {
            if (line.length < 54) continue;
            if (!line.startsWith('ATOM') && !line.startsWith('HETATM')) continue;
            if (line[21] !== chainId) continue;
            const atomName = line.substring(12, 16).trim();
            if (atomName !== "C1'") continue;
            const resid = parseInt(line.substring(22, 26).trim());
            const resn = line.substring(17, 20).trim();
            const base = resNameToBase[resn];
            if (!base) continue;
            const x = parseFloat(line.substring(30, 38));
            const y = parseFloat(line.substring(38, 46));
            const z = parseFloat(line.substring(46, 54));
            residues[resid] = { chain: chainId, resid, base, x, y, z };
        }
        return residues;
    }

    const ch1Res = parseChainC1(pdbText, chain1);
    const ch2Res = parseChainC1(pdbText, chain2);

    // Sort chain1 residues by resid ascending
    const ch1Sorted = Object.values(ch1Res).sort((a, b) => a.resid - b.resid);
    const ch2List = Object.values(ch2Res);
    const used = new Set();

    const pairs = [];
    for (const r1 of ch1Sorted) {
        let bestDist = Infinity, bestR2 = null;
        for (const r2 of ch2List) {
            if (used.has(r2.resid)) continue;
            // Check Watson-Crick complementarity
            if (WC[r1.base] !== r2.base) continue;
            const dx = r1.x - r2.x, dy = r1.y - r2.y, dz = r1.z - r2.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (dist < bestDist) {
                bestDist = dist;
                bestR2 = r2;
            }
        }
        if (bestR2 && bestDist < 12) {
            used.add(bestR2.resid);
            pairs.push({
                top: { chain: r1.chain, resid: r1.resid, base: r1.base },
                bot: { chain: bestR2.chain, resid: bestR2.resid, base: bestR2.base },
            });
        }
    }
    return pairs;
}

// Parse all DNA resids for a chain from PDB text
function parseDnaResids(pdbText, chainId) {
    const resids = new Set();
    for (const line of pdbText.split('\n')) {
        if (line.length < 54) continue;
        if (!line.startsWith('ATOM') && !line.startsWith('HETATM')) continue;
        if (line[21] !== chainId) continue;
        resids.add(parseInt(line.substring(22, 26).trim()));
    }
    return Array.from(resids).sort((a, b) => a - b);
}

function buildDnaSelector(pairs) {
    const container = document.getElementById('dna-selector');
    container.innerHTML = '';
    if (!pairs.length) return;

    const inner = document.createElement('div');
    inner.className = 'dna-selector-inner';

    const topChain = pairs[0].top.chain;
    const botChain = pairs[0].bot.chain;

    function makeSpan(cls, text) {
        const s = document.createElement('span');
        s.className = cls;
        s.textContent = text;
        return s;
    }

    // Invisible spacer matching the width of a dna-end element
    function makeEndSpacer(matchText) {
        const s = makeSpan('dna-end', matchText);
        s.style.visibility = 'hidden';
        return s;
    }

    // Which positions get resid markers: first, last, every 5th
    function shouldShowResid(i) {
        return i === 0 || i === pairs.length - 1 || (i + 1) % 5 === 0;
    }

    // ── Top resid row (actual PDB resids for top strand) ──
    const topResidRow = document.createElement('div');
    topResidRow.className = 'dna-row';
    topResidRow.appendChild(makeSpan('dna-label', ''));
    topResidRow.appendChild(makeEndSpacer("5\u2032\u2500"));
    for (let i = 0; i < pairs.length; i++) {
        topResidRow.appendChild(makeSpan('bp-resid',
            shouldShowResid(i) ? String(pairs[i].top.resid) : ''));
    }
    topResidRow.appendChild(makeEndSpacer("\u2500\u20323\u2032"));
    inner.appendChild(topResidRow);

    // ── Top base row ──
    const topRow = document.createElement('div');
    topRow.className = 'dna-row';
    topRow.appendChild(makeSpan('dna-label', 'chain ' + topChain));
    topRow.appendChild(makeSpan('dna-end', "5\u2032\u2500"));
    for (let i = 0; i < pairs.length; i++) {
        const cell = document.createElement('span');
        cell.className = 'bp-cell selected';
        cell.dataset.idx = i;
        cell.dataset.row = 'top';
        cell.textContent = pairs[i].top.base;
        cell.title = topChain + ':' + pairs[i].top.resid + ' ' + pairs[i].top.base;
        topRow.appendChild(cell);
    }
    topRow.appendChild(makeSpan('dna-end', "\u2500\u20323\u2032"));
    inner.appendChild(topRow);

    // ── Pipe row ──
    const pipeRow = document.createElement('div');
    pipeRow.className = 'dna-row';
    pipeRow.appendChild(makeSpan('dna-label', ''));
    pipeRow.appendChild(makeEndSpacer("5\u2032\u2500"));
    for (let i = 0; i < pairs.length; i++) {
        pipeRow.appendChild(makeSpan('bp-pipe', '|'));
    }
    pipeRow.appendChild(makeEndSpacer("\u2500\u20323\u2032"));
    inner.appendChild(pipeRow);

    // ── Bottom base row ──
    const botRow = document.createElement('div');
    botRow.className = 'dna-row';
    botRow.appendChild(makeSpan('dna-label', 'chain ' + botChain));
    botRow.appendChild(makeSpan('dna-end', "3\u2032\u2500"));
    for (let i = 0; i < pairs.length; i++) {
        const cell = document.createElement('span');
        cell.className = 'bp-cell selected';
        cell.dataset.idx = i;
        cell.dataset.row = 'bot';
        cell.textContent = pairs[i].bot.base;
        cell.title = botChain + ':' + pairs[i].bot.resid + ' ' + pairs[i].bot.base;
        botRow.appendChild(cell);
    }
    botRow.appendChild(makeSpan('dna-end', "\u2500\u20325\u2032"));
    inner.appendChild(botRow);

    // ── Bottom resid row (actual PDB resids for bottom strand) ──
    const botResidRow = document.createElement('div');
    botResidRow.className = 'dna-row';
    botResidRow.appendChild(makeSpan('dna-label', ''));
    botResidRow.appendChild(makeEndSpacer("3\u2032\u2500"));
    for (let i = 0; i < pairs.length; i++) {
        botResidRow.appendChild(makeSpan('bp-resid',
            shouldShowResid(i) ? String(pairs[i].bot.resid) : ''));
    }
    botResidRow.appendChild(makeEndSpacer("\u2500\u20325\u2032"));
    inner.appendChild(botResidRow);

    container.appendChild(inner);

    // -- Drag selection events --
    inner.addEventListener('mousedown', function(e) {
        const cell = e.target.closest('.bp-cell');
        if (!cell) return;
        e.preventDefault();
        dragAnchor = parseInt(cell.dataset.idx);
        bpDragging = true;
        selStart = selEnd = dragAnchor;
        updateDnaSelection();
    });

    inner.addEventListener('mousemove', function(e) {
        if (!bpDragging) return;
        const cell = e.target.closest('.bp-cell');
        if (!cell) return;
        const idx = parseInt(cell.dataset.idx);
        selStart = Math.min(dragAnchor, idx);
        selEnd = Math.max(dragAnchor, idx);
        updateDnaSelection();
    });

    document.addEventListener('mouseup', function() {
        bpDragging = false;
    });

    // Touch events for mobile
    inner.addEventListener('touchstart', function(e) {
        const cell = e.target.closest('.bp-cell');
        if (!cell) return;
        e.preventDefault();
        dragAnchor = parseInt(cell.dataset.idx);
        bpDragging = true;
        selStart = selEnd = dragAnchor;
        updateDnaSelection();
    }, { passive: false });

    inner.addEventListener('touchmove', function(e) {
        if (!bpDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const cell = el && el.closest ? el.closest('.bp-cell') : null;
        if (!cell) return;
        const idx = parseInt(cell.dataset.idx);
        selStart = Math.min(dragAnchor, idx);
        selEnd = Math.max(dragAnchor, idx);
        updateDnaSelection();
    }, { passive: false });

    document.addEventListener('touchend', function() {
        bpDragging = false;
    });
}

function updateDnaSelection() {
    // Toggle .selected class on all .bp-cell elements
    document.querySelectorAll('#dna-selector .bp-cell').forEach(cell => {
        const idx = parseInt(cell.dataset.idx);
        cell.classList.toggle('selected', idx >= selStart && idx <= selEnd);
    });

    const count = selEnd - selStart + 1;
    document.getElementById('dna-sel-count').textContent = count;

    if (bpPairs.length === 0) return;

    // Compute lo/hi from ALL selected pairs (not just endpoints,
    // in case bottom-strand resids aren't perfectly monotonic)
    let topLo = Infinity, topHi = -Infinity;
    let botLo = Infinity, botHi = -Infinity;
    for (let i = selStart; i <= selEnd; i++) {
        const tr = bpPairs[i].top.resid, br = bpPairs[i].bot.resid;
        if (tr < topLo) topLo = tr;
        if (tr > topHi) topHi = tr;
        if (br < botLo) botLo = br;
        if (br > botHi) botHi = br;
    }
    document.getElementById('sel-dna1-lo').value = topLo;
    document.getElementById('sel-dna1-hi').value = topHi;
    document.getElementById('sel-dna2-lo').value = botLo;
    document.getElementById('sel-dna2-hi').value = botHi;

    // Count actual residues in each lo/hi range to detect mismatches
    const ch1 = bpPairs[0].top.chain;
    const ch2 = bpPairs[0].bot.chain;
    const ch1All = dnaChainResids[ch1] || [];
    const ch2All = dnaChainResids[ch2] || [];
    const topResCount = ch1All.filter(r => r >= topLo && r <= topHi).length;
    const botResCount = ch2All.filter(r => r >= botLo && r <= botHi).length;

    // Detect gaps (missing residues within each range)
    const topExpected = topHi - topLo + 1;
    const botExpected = botHi - botLo + 1;
    const topGaps = topExpected - topResCount;
    const botGaps = botExpected - botResCount;

    const warnEl = document.getElementById('dna-sel-warning');
    const warnings = [];
    if (topGaps > 0) {
        const missing = [];
        for (let r = topLo; r <= topHi; r++) {
            if (!ch1All.includes(r)) missing.push(r);
        }
        warnings.push(`Chain ${ch1} missing residue(s) ${missing.join(', ')}`);
    }
    if (botGaps > 0) {
        const missing = [];
        for (let r = botLo; r <= botHi; r++) {
            if (!ch2All.includes(r)) missing.push(r);
        }
        warnings.push(`Chain ${ch2} missing residue(s) ${missing.join(', ')}`);
    }
    if (topResCount !== botResCount && topGaps === 0 && botGaps === 0) {
        warnings.push(`Unequal strand lengths: ${topResCount} vs ${botResCount} residues`);
    }
    warnEl.textContent = warnings.length ? '\u26a0 ' + warnings.join('; ') : '';
}

function initDnaSelector() {
    const ch1 = document.getElementById('sel-dna1-chain').value;
    const ch2 = document.getElementById('sel-dna2-chain').value;
    if (!ch1 || !ch2 || !guestPdbString) {
        document.getElementById('dna-selector-wrap').classList.add('hidden');
        return;
    }

    // Store full resid sets for strand-length validation
    dnaChainResids[ch1] = parseDnaResids(guestPdbString, ch1);
    dnaChainResids[ch2] = parseDnaResids(guestPdbString, ch2);

    const pairs = detectBasePairing(guestPdbString, ch1, ch2);
    if (pairs.length < 2) {
        document.getElementById('dna-selector-wrap').classList.add('hidden');
        bpPairs = [];
        return;
    }
    bpPairs = pairs;
    selStart = 0;
    selEnd = pairs.length - 1;
    buildDnaSelector(pairs);
    document.getElementById('dna-selector-wrap').classList.remove('hidden');
    updateDnaSelection();
}

// ── Start Scan ──────────────────────────────────────────────────
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function startScan() {
    const params = getSelectionParams();
    scaffoldCode = document.getElementById('scaffold-toggle').checked ? '9YZK' : '9YZJ';

    // Ensure scaffold data is loaded
    if (!scaffoldData[scaffoldCode]) {
        setStatus('status-selection', 'Loading scaffold data...', 'info');
        await fetchScaffoldData(scaffoldCode);
    }

    // Hide stage 3 while running
    document.getElementById('stage3').classList.add('hidden');
    const scanBtn = document.getElementById('btn-scan');
    scanBtn.disabled = true;
    scanBtn.textContent = 'Running...';
    document.getElementById('progress-fill').classList.remove('done');

    // First ensure we have truncated PDB
    if (!truncatedPdbStr) {
        truncatedPdbStr = window.pyStepA(
            guestPdbString, JSON.stringify(params.protChains),
            params.dna1Chain, params.dna1Lo, params.dna1Hi,
            params.dna2Chain, params.dna2Lo, params.dna2Hi,
            params.hetatm
        );
    }

    try {
        // Initialize pipeline data
        updateProgress('Init', 5, 100, 'Preparing data...');
        await sleep(50);
        const sd = scaffoldData[scaffoldCode];
        window.pyPipeInit(
            truncatedPdbStr,
            JSON.stringify(sd.json),
            sd.pdb,
            JSON.stringify(sd.matesJson),
            sd.botPdb,
            sd.topPdb
        );

        // Step B: Find registers
        updateProgress('Registers', 10, 100, 'Finding binding registers...');
        await sleep(50);
        const nRegisters = parseInt(window.pyPipeStepB(), 10) || 0;

        // Step D: Categorize
        updateProgress('Categorize', 40, 100, `Categorizing ${nRegisters} registers...`);
        await sleep(50);
        window.pyPipeStepD();

        // Step E: Rank
        updateProgress('Rank', 65, 100, 'Ranking registers...');
        await sleep(50);
        window.pyPipeStepE();

        // Step F: Diagram
        updateProgress('Diagram', 85, 100, 'Generating diagram...');
        await sleep(50);
        const resultJson = window.pyPipeStepF();

        const result = JSON.parse(resultJson);
        onPipelineComplete(result);
    } catch(e) {
        setStatus('status-pipeline', `Pipeline error: ${e.message}`, 'error');
        scanBtn.disabled = false;
        scanBtn.textContent = 'Scan Possible Binding Registers';
        document.getElementById('progress-fill').classList.add('done');
    }
}

// ── Progress callback (called from Python) ──────────────────────
window.updateProgress = function(step, current, total, message) {
    const pct = total > 0 ? Math.round(100 * current / total) : 0;
    document.getElementById('progress-fill').style.width = pct + '%';
    document.getElementById('progress-text').textContent = message || `${step}: ${current}/${total}`;
};

// ── Pipeline Complete ───────────────────────────────────────────
function onPipelineComplete(result) {
    rankedResults = result.ranked;
    registerPdbs = result.register_pdbs;
    registerSymPdbs = result.register_sym_pdbs || {};
    // Sequence data for .seqs download
    window._seqData = {
        scaffTopSeq: result.scaff_top_seq || '',
        guestSeq1: result.guest_seq1 || '',
        guestSeq2: result.guest_seq2 || '',
        guestDnaChains: result.guest_dna_chains || [],
        topChain: result.top_chain || '',
    };

    // Show results stage
    document.getElementById('stage3').classList.remove('hidden');
    const scanBtn = document.getElementById('btn-scan');
    scanBtn.disabled = false;
    scanBtn.textContent = 'Scan Possible Binding Registers';
    updateProgress('Done', 1, 1, 'Pipeline complete!');
    document.getElementById('progress-fill').classList.add('done');

    // Summary
    const nTotal = rankedResults.length;
    const nOk = rankedResults.filter(r => r.classification !== 'CLASH').length;
    const nClash = nTotal - nOk;
    const rank1 = rankedResults.length > 0 ? rankedResults[0] : null;

    let html = '<div class="metric"><strong>' + nOk + '</strong> non-clashing registers</div>';
    html += '<div class="metric"><strong>' + nClash + '</strong> clashing registers</div>';
    if (rank1 && rank1.classification !== 'CLASH') {
        html += '<div class="metric" style="margin-top:0.5rem">Rank 1: <strong>' + rank1.obj_name + '</strong></div>';
        html += '<div class="metric">min_dist: <strong>' + rank1.min_dist.toFixed(1) + ' \u00c5</strong></div>';
        html += '<div class="metric">Classification: ' + rank1.classification + '</div>';
    }
    document.getElementById('results-summary').innerHTML = html;

    // SVG diagram
    document.getElementById('svg-container').innerHTML = result.svg;

    // Load rank 1 in viewer 3
    if (rank1) {
        loadRegisterInViewer3(rank1.obj_name);
    }
}

// ── Register click handler ──────────────────────────────────────
window.onRegisterBarClick = function(objName) {
    loadRegisterInViewer3(objName);
};

async function loadRegisterInViewer3(objName) {
    const pdbStr = registerPdbs[objName];
    if (!pdbStr || !plugin3) return;

    // Update active highlight in SVG
    document.querySelectorAll('.register-bar.active').forEach(el => el.classList.remove('active'));
    document.querySelectorAll(`.register-bar[data-obj-name="${objName}"]`).forEach(el => el.classList.add('active'));

    activeRegister = objName;

    // Find rank info
    const reg = rankedResults.find(r => r.obj_name === objName);
    const label = reg ? `Rank ${reg.rank}: ${objName}` : objName;
    document.getElementById('viewer3-label').textContent = label;

    // Update summary box to show this register's details
    if (reg) updateSummaryForRegister(reg);

    const p = plugin3.plugin;
    await p.clear();

    const sd = scaffoldData[scaffoldCode];
    const scaffJson = sd.json;
    const dnaChains = scaffJson.dna_chains;   // ['A','B'] or ['E','F']
    const protChain = Object.keys(scaffJson.chains).find(
        ch => scaffJson.chains[ch].type === 'protein');

    // 1. Crystal contacts: symmetry environment in light gray
    //    (ASU also gray underneath; per-chain overlay covers it)
    //    Strip HETATM (Mg etc.) before loading so ions don't appear in symmetry copies
    const scaffAtomOnly = sd.pdb.split('\n').filter(l =>
        !l.startsWith('HETATM')).join('\n');
    try {
        const data = await p.builders.data.rawData({ data: scaffAtomOnly, label: 'scaffold' });
        const trajectory = await p.builders.structure.parseTrajectory(data, 'pdb');
        await p.builders.structure.hierarchy.applyPreset(trajectory, 'preset-trajectory-crystal-contacts');
        const structs = p.managers.structure.hierarchy.current.structures;
        for (const s of structs) {
            await p.managers.structure.component.updateRepresentationsTheme(s.components, {
                color: 'uniform', colorParams: { value: 0xbbbbbb }
            });
        }
    } catch (e) {
        console.warn('Crystal contacts preset failed:', e);
    }

    // 2. ASU overlay: scaffold protein (light blue), DNA chains (black/wheat)
    await loadAndColor(plugin3, extractChains(sd.pdb, [protChain]), 0x7ec8e3, 'scaffold protein');
    await loadAndColor(plugin3, extractChains(sd.pdb, [dnaChains[0]]), 0x222222, 'DNA strand 1');
    await loadAndColor(plugin3, extractChains(sd.pdb, [dnaChains[1]]), 0xd4a96a, 'DNA strand 2');

    // 3. Guest protein (magenta) — strip DNA
    const guestProtOnly = stripDnaChains(pdbStr);
    const remappedGuest = remapChainIds(guestProtOnly, sd.pdb);
    await loadAndColor(plugin3, remappedGuest, 0xcc0088, label);

    // 4. Guest symmetry copy (light pink) — strip DNA
    const symPdb = registerSymPdbs[objName] || '';
    if (symPdb) {
        const symProtOnly = stripDnaChains(symPdb);
        await loadAndColor(plugin3, symProtOnly, 0xffaacc, 'sym copy');
    }

    // 5. Style
    hideWaterAndIons(plugin3);
    applyStylized(plugin3);

    // 6. Focus camera on the guest domain (magenta)
    const sphere = pdbBoundingSphere(remappedGuest);
    if (sphere && p.canvas3d) {
        const center = new Float64Array(sphere.center);
        p.canvas3d.camera.focus(center, sphere.radius * 1.5, 250);
    }
}

// ── Summary update ──────────────────────────────────────────────
function updateSummaryForRegister(reg) {
    const nTotal = rankedResults.length;
    const nOk = rankedResults.filter(r => r.classification !== 'CLASH').length;
    const nClash = nTotal - nOk;

    let html = '<div class="metric"><strong>' + nOk + '</strong> non-clashing registers</div>';
    html += '<div class="metric"><strong>' + nClash + '</strong> clashing registers</div>';
    html += '<div class="metric" style="margin-top:0.5rem; color:gray; font-size:0.85em">To inspect the non-clashing registers see the table below.</div>';
    html += '<div class="metric" style="margin-top:0.5rem">Viewing: <strong>Rank ' + reg.rank + '</strong></div>';
    html += '<div class="metric">' + reg.obj_name + '</div>';
    html += '<div class="metric">min_dist: <strong>' + reg.min_dist.toFixed(1) + ' \u00c5</strong></div>';
    html += '<div class="metric">Classification: ' + reg.classification + '</div>';
    html += '<div class="metric">Orientation: ' + reg.orientation + '</div>';
    html += '<div class="metric">Positions: ' + reg.start_pos + '\u2013' + reg.end_pos + '</div>';
    document.getElementById('results-summary').innerHTML = html;
}

// ── Chain ID remapping ──────────────────────────────────────────
function remapChainIds(guestPdb, scaffoldPdb) {
    // Find chain IDs used in scaffold
    const usedChains = new Set();
    for (const line of scaffoldPdb.split('\n')) {
        if ((line.startsWith('ATOM') || line.startsWith('HETATM')) && line.length > 21) {
            usedChains.add(line[21]);
        }
    }
    // Find chain IDs used in guest
    const guestChains = new Set();
    for (const line of guestPdb.split('\n')) {
        if ((line.startsWith('ATOM') || line.startsWith('HETATM')) && line.length > 21) {
            guestChains.add(line[21]);
        }
    }
    // Find clashing chains
    const clashing = new Set();
    for (const ch of guestChains) {
        if (usedChains.has(ch)) clashing.add(ch);
    }
    if (clashing.size === 0) return guestPdb;
    // Build mapping: clashing guest chains -> unused chain IDs
    const allUsed = new Set([...usedChains, ...guestChains]);
    const candidates = 'XYZWVUTSRQPONMLKJIHGFDCBAxyzwvutsrqponmlkjihgfdcba0123456789';
    const mapping = {};
    let ci = 0;
    for (const ch of clashing) {
        while (ci < candidates.length && allUsed.has(candidates[ci])) ci++;
        if (ci < candidates.length) {
            mapping[ch] = candidates[ci];
            allUsed.add(candidates[ci]);
            ci++;
        }
    }
    // Apply remapping to ATOM/HETATM/TER records
    const lines = guestPdb.split('\n');
    const remapped = lines.map(line => {
        if ((line.startsWith('ATOM') || line.startsWith('HETATM') || line.startsWith('TER')) && line.length > 21) {
            const ch = line[21];
            if (mapping[ch]) {
                return line.substring(0, 21) + mapping[ch] + line.substring(22);
            }
        }
        return line;
    });
    return remapped.join('\n');
}

// ── Identify DNA chain IDs in a PDB string ──────────────────────
function findDnaChainIds(pdbStr) {
    const dnaResnames = new Set(['DA', 'DT', 'DC', 'DG', ' DA', ' DT', ' DC', ' DG']);
    const chainResnames = {};
    for (const line of pdbStr.split('\n')) {
        if (!line.startsWith('ATOM') || line.length < 54) continue;
        const ch = line[21];
        const resn = line.substring(17, 20).trim();
        if (!chainResnames[ch]) chainResnames[ch] = new Set();
        chainResnames[ch].add(resn);
    }
    const dnaChains = new Set();
    for (const [ch, resnames] of Object.entries(chainResnames)) {
        if ([...resnames].every(rn => dnaResnames.has(rn))) dnaChains.add(ch);
    }
    return dnaChains;
}

// ── Strip DNA chains from PDB string ────────────────────────────
function stripDnaChains(pdbStr) {
    const dnaChains = findDnaChainIds(pdbStr);
    if (dnaChains.size === 0) return pdbStr;
    return pdbStr.split('\n').filter(line => {
        if ((line.startsWith('ATOM') || line.startsWith('HETATM') || line.startsWith('TER')) && line.length > 21) {
            return !dnaChains.has(line[21]);
        }
        return true;
    }).join('\n');
}

// ── Extract only DNA chains from PDB string ─────────────────────
function extractDnaOnly(pdbStr) {
    const dnaChains = findDnaChainIds(pdbStr);
    if (dnaChains.size === 0) return '';
    return pdbStr.split('\n').filter(line => {
        if ((line.startsWith('ATOM') || line.startsWith('TER')) && line.length > 21) {
            return dnaChains.has(line[21]);
        }
        return false;
    }).join('\n');
}

// ── Extract ATOM lines for specific chains (skip HETATM) ────────
function extractChains(pdbStr, chains) {
    const keep = new Set(chains);
    return pdbStr.split('\n').filter(line => {
        if (line.startsWith('ATOM') && line.length > 21) return keep.has(line[21]);
        if (line.startsWith('TER') && line.length > 21) return keep.has(line[21]);
        return false;
    }).join('\n');
}

// ── Load PDB string into viewer and color uniformly ─────────────
async function loadAndColor(viewer, pdbStr, colorHex, label) {
    if (!pdbStr.trim()) return;
    await viewer.loadStructureFromData(pdbStr, 'pdb', { dataLabel: label || 'structure' });
    const structs = viewer.plugin.managers.structure.hierarchy.current.structures;
    const s = structs[structs.length - 1]; // last loaded
    if (s) {
        await viewer.plugin.managers.structure.component.updateRepresentationsTheme(s.components, {
            color: 'uniform', colorParams: { value: colorHex }
        });
    }
}

// ── Insert TER records at chain boundaries ──────────────────────
function insertTerRecords(pdbStr) {
    const lines = pdbStr.split('\n');
    const result = [];
    let lastChain = null;
    for (const line of lines) {
        if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
            if (line.length > 21) {
                const ch = line[21];
                if (lastChain !== null && ch !== lastChain) {
                    result.push('TER');
                }
                lastChain = ch;
            }
            result.push(line);
        } else if (line.startsWith('TER')) {
            continue; // skip existing TER records; we add our own
        } else if (line.trim()) {
            result.push(line);
        }
    }
    if (lastChain !== null) result.push('TER');
    return result.join('\n');
}

// ── Compute bounding sphere of ATOM coords in PDB string ────────
function pdbBoundingSphere(pdbStr) {
    let sx = 0, sy = 0, sz = 0, n = 0;
    for (const line of pdbStr.split('\n')) {
        if (!line.startsWith('ATOM') || line.length < 54) continue;
        sx += parseFloat(line.substring(30, 38));
        sy += parseFloat(line.substring(38, 46));
        sz += parseFloat(line.substring(46, 54));
        n++;
    }
    if (n === 0) return null;
    const cx = sx / n, cy = sy / n, cz = sz / n;
    let maxR2 = 0;
    for (const line of pdbStr.split('\n')) {
        if (!line.startsWith('ATOM') || line.length < 54) continue;
        const dx = parseFloat(line.substring(30, 38)) - cx;
        const dy = parseFloat(line.substring(38, 46)) - cy;
        const dz = parseFloat(line.substring(46, 54)) - cz;
        const r2 = dx * dx + dy * dy + dz * dz;
        if (r2 > maxR2) maxR2 = r2;
    }
    return { center: [cx, cy, cz], radius: Math.sqrt(maxR2) };
}

// ── Download current model as PDB ────────────────────────────────
function downloadCurrentPdb() {
    if (!activeRegister || !scaffoldData[scaffoldCode]) return;

    const sd = scaffoldData[scaffoldCode];
    const scaffJson = sd.json;
    const dnaChains = scaffJson.dna_chains;
    const protChain = Object.keys(scaffJson.chains).find(
        ch => scaffJson.chains[ch].type === 'protein');

    // Extract CRYST1 record from scaffold PDB
    const cryst1 = sd.pdb.split('\n').find(l => l.startsWith('CRYST1')) || '';

    // Scaffold ASU (ATOM only, no HETATM cations)
    const scaffAtoms = extractChains(sd.pdb, [protChain, ...dnaChains]);

    // Guest: remap chains, then split into protein and DNA
    const pdbStr = registerPdbs[activeRegister];
    if (!pdbStr) return;
    const remappedGuest = remapChainIds(pdbStr, sd.pdb);
    const guestProtein = stripDnaChains(remappedGuest);
    const guestDna = extractDnaOnly(remappedGuest);

    // MODEL 1: scaffold ASU + guest protein
    // MODEL 2: guest DNA (separate model avoids PyMOL drawing inter-chain bonds)
    let combined = '';
    if (cryst1) combined += cryst1 + '\n';
    combined += 'REMARK   GuestScan model: ' + activeRegister + ' on scaffold ' + scaffoldCode + '\n';
    combined += 'MODEL        1\n';
    combined += insertTerRecords(scaffAtoms) + '\n';
    combined += insertTerRecords(guestProtein) + '\n';
    combined += 'ENDMDL\n';
    if (guestDna.trim()) {
        combined += 'MODEL        2\n';
        combined += insertTerRecords(guestDna) + '\n';
        combined += 'ENDMDL\n';
    }
    combined += 'END\n';

    // Trigger download
    const blob = new Blob([combined], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = activeRegister + '_' + scaffoldCode + '.pdb';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// ── Download ranked sequences file ────────────────────────────────
function downloadSequences() {
    if (!rankedResults.length || !window._seqData) return;
    const sd = window._seqData;
    const WC = { A: 'T', T: 'A', G: 'C', C: 'G' };
    const wcComp = s => [...s].map(b => WC[b] || b).join('');

    const scaffJson = scaffoldData[scaffoldCode].json;
    const dnaChains = scaffJson.dna_chains;
    const topChain = sd.topChain;
    const botChain = dnaChains.find(c => c !== topChain) || dnaChains[1];
    const scaffBotDisplay = wcComp(sd.scaffTopSeq);
    const gch1 = sd.guestDnaChains[0] || '?';
    const gch2 = sd.guestDnaChains[1] || '?';
    const botGuestDisplay = wcComp(sd.guestSeq1);

    let out = '';
    out += `>scaffold_dna_${scaffJson.pdb_id}_chain${topChain}+${botChain}\n`;
    out += `  top  5'-${sd.scaffTopSeq}-3'\n`;
    out += `  bot  3'-${scaffBotDisplay}-5'\n`;
    out += `>guest_dbd_chain${gch1}+${gch2}\n`;
    out += `  top  5'-${sd.guestSeq1}-3'  (chain ${gch1}, used as top in fwd)\n`;
    out += `  bot  3'-${botGuestDisplay}-5'  (chain ${gch2}, used as top in rev)\n`;
    for (const r of rankedResults) {
        const tag = r.classification;
        out += `>rank${r.rank}.${r.obj_name}  pos=${r.start_pos}..${r.end_pos}  `;
        out += `${r.orientation}  min=${r.min_dist.toFixed(2)}A  [${tag}]\n`;
        out += `  top  5'-${r.composite_top}-3'\n`;
        out += `  bot  3'-${r.composite_bot}-5'\n`;
    }

    const blob = new Blob([out], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ranked_sequences_' + scaffoldCode + '.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// ── Utility ─────────────────────────────────────────────────────
function setStatus(id, msg, type) {
    const el = document.getElementById(id);
    el.textContent = msg;
    el.className = 'status ' + (type || '');
}


</script>

<!-- ═══════════════════════════════════════════════════════════════ -->
<!--  Pyodide Initialization & Python Bridge                       -->
<!-- ═══════════════════════════════════════════════════════════════ -->
<script>
// ── Initialize Pyodide and load pipeline module ─────────────────
let pyodide = null;

async function initPyodide() {
    document.querySelector('#loading-overlay .msg').textContent = 'Loading Pyodide runtime...';
    pyodide = await loadPyodide();

    document.querySelector('#loading-overlay .msg').textContent = 'Installing NumPy & SciPy...';
    await pyodide.loadPackage(['numpy', 'scipy']);

    document.querySelector('#loading-overlay .msg').textContent = 'Loading pipeline module...';
    // Fetch pipeline.py and write to Pyodide virtual filesystem
    const pipelineCode = await fetch('./pipeline.py').then(r => r.text());
    pyodide.FS.writeFile('/home/pyodide/pipeline.py', pipelineCode);

    // Define the bridge functions in Python
    await pyodide.runPythonAsync(`
import json
import sys
sys.path.insert(0, '/home/pyodide')
import pipeline

def _call_validate(pdb_string, prot_chains_json, dna1_chain, dna1_lo, dna1_hi,
                   dna2_chain, dna2_lo, dna2_hi):
    prot_chains = json.loads(prot_chains_json)
    ok, msg, info = pipeline.validate_guest_selection(
        pdb_string, prot_chains, dna1_chain, int(dna1_lo), int(dna1_hi),
        dna2_chain, int(dna2_lo), int(dna2_hi))
    return json.dumps({'ok': ok, 'message': msg})

def _call_step_a(pdb_string, prot_chains_json, dna1_chain, dna1_lo, dna1_hi,
                 dna2_chain, dna2_lo, dna2_hi, hetatm):
    prot_chains = json.loads(prot_chains_json)
    return pipeline.step_A_process_guest(
        pdb_string, prot_chains, dna1_chain, int(dna1_lo), int(dna1_hi),
        dna2_chain, int(dna2_lo), int(dna2_hi), hetatm=bool(hetatm))

_pipe = {}  # intermediate results between steps

def _pipe_init(guest_pdb_str, scaffold_json_str, scaffold_pdb_str,
               mates_json_str, bot_pdb_str, top_pdb_str):
    _pipe['guest_pdb_str'] = guest_pdb_str
    _pipe['scaffold_json'] = json.loads(scaffold_json_str)
    _pipe['scaffold_pdb_str'] = scaffold_pdb_str
    _pipe['mates_json'] = json.loads(mates_json_str)
    _pipe['bot_pdb_str'] = bot_pdb_str
    _pipe['top_pdb_str'] = top_pdb_str
    return ''

def _pipe_step_b():
    _pipe['b_result'] = pipeline.step_B_find_registers(
        _pipe['guest_pdb_str'], _pipe['scaffold_pdb_str'], _pipe['scaffold_json'],
        mates_json=_pipe['mates_json'], bot_pdb_str=_pipe['bot_pdb_str'],
        top_pdb_str=_pipe['top_pdb_str'])
    n = len(_pipe['b_result'].get('registers', []))
    return str(n)

def _pipe_step_d():
    _pipe['d_result'] = pipeline.step_D_categorize(
        _pipe['b_result'], _pipe['scaffold_pdb_str'], _pipe['scaffold_json'],
        mates_json=_pipe['mates_json'])
    return ''

def _pipe_step_e():
    _pipe['e_result'] = pipeline.step_E_rank(
        _pipe['d_result'], _pipe['scaffold_pdb_str'], _pipe['scaffold_json'],
        _pipe['guest_pdb_str'], mates_json=_pipe['mates_json'])
    return ''

def _pipe_step_f():
    svg = pipeline.step_F_diagram_svg(_pipe['e_result'], _pipe['scaffold_json'],
                                       _pipe['d_result'])
    register_pdbs = _pipe['b_result'].get('register_pdbs', {})
    register_sym_pdbs = _pipe['e_result'].get('register_sym_pdbs', {})
    ranked = _pipe['e_result']['ranked']
    ranked_clean = []
    for r in ranked:
        rc = {k: v for k, v in r.items()
              if k not in ('pdb_string', 'neighbors', 'closest_dists')}
        ranked_clean.append(rc)

    result = json.dumps({
        'ranked': ranked_clean,
        'register_pdbs': register_pdbs,
        'register_sym_pdbs': register_sym_pdbs,
        'svg': svg,
        'scaff_top_seq': _pipe['e_result'].get('scaff_top_seq', ''),
        'guest_seq1': _pipe['e_result'].get('guest_seq1', ''),
        'guest_seq2': _pipe['e_result'].get('guest_seq2', ''),
        'guest_dna_chains': _pipe['e_result'].get('guest_dna_chains', []),
        'top_chain': _pipe['e_result'].get('top_chain', ''),
    })
    _pipe.clear()
    return result
`);

    // Create JS-callable proxies
    window.pyValidate = pyodide.globals.get('_call_validate');
    window.pyStepA = pyodide.globals.get('_call_step_a');
    window.pyPipeInit = pyodide.globals.get('_pipe_init');
    window.pyPipeStepB = pyodide.globals.get('_pipe_step_b');
    window.pyPipeStepD = pyodide.globals.get('_pipe_step_d');
    window.pyPipeStepE = pyodide.globals.get('_pipe_step_e');
    window.pyPipeStepF = pyodide.globals.get('_pipe_step_f');

    document.getElementById('loading-overlay').classList.add('hidden');
    console.log('Pyodide + pipeline ready');
}

// Boot: init viewers + scaffold data + Pyodide in parallel
async function bootAll() {
    await Promise.all([
        initViewers(),
        fetchScaffoldData('9YZJ'),
        fetchScaffoldData('9YZK'),
        initPyodide(),
    ]);
}
bootAll();
</script>

</div><!-- .page-wrap -->
</body>
</html>
